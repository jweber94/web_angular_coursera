# Notes week 4

## Component Based Architecture
+ Components are a special type of directive
    - Components are part of the AngularJS version 2 and are introduced in the latest versions of AngularJS version 1
+ Basics to components and component based architecture
    - "Components only control their own view and data."
        * They never modify data or DOM outside their scope 
        * AngularJS components always use isolate scope!
    - "Components have well-defined public API - Input and Output"
        * Inputs are just be done by one way bindings (i.e. `<` or `@`) --> The component should ***NOT*** modify the value of a handed over variable
            - Even if a one-way binding is fixed in the memory that the bound variable is pointing to, the component would be able to modify the variables value. _BUT_ in order to have a well defined API (aka Input-Output behaviour), the value behind a bound variable should ***NEVER*** be changed!
            - APIs (aka a component) should always hand over an output value!
                * The output should be a bidirectional binding by using the `&` binding operation!
                * The data should be passed to the caller of the callback through a parameter map `{key: val}`
    - "Components have well-defined lifecycle"
        * That meanes we have methods that we could call at a defined time of our application
            - i.e. `$onInit` to initialize things for your controller
            - i.e. `$inChanges(changeObj)` will be called whenever a one-way binding is updated
                * `changeObj.currentValue` and `changeObj.previousValue` are attributes of the changed object such that we can track changes. These two attributes are automatically generated by AngularJS
            - i.e. `$postLink` - similar to the `link` attribute in the directive definition
                + In order to use this, we need to inject the `$element` service into our controller ~ element is an abstraction for jquery in angular!
            - i.e. `$onDestroy` - is called when the scope is about to get destroyed
                + _These functions are defined ***on the controller***_
    - "Application is a tree of components"
        * The entire web application shoud be comprised of components
            - Each one would have a well-defined input and output
            - Two-Way Binding is minimized as much as possible
+ Component definition in AngularJS: 
[](images/component_definition.png)
[](images/component_definition_2.png)
+ The main difference/advantage of a controller over a directive is that it is much easier to define since it needs an definition object instead of a creation function and it defines a `$ctrl` service within the controller where it is used. Therefore, there is no need to use the `controller as ctrl` syntax like it was useful in the directive implementation
    * The controller definition is done by an object literal in the registration on `angular.module("AppName", []).component("ComponentName", objLiteral)`
+ See Lecture 33 part 2 for an implementation example
+ In AngularJS version 2, we do not want to depend on `$scope`. Therefore, components are a very good possibility to do this

## Event System
+ To share data between components (or directives) we can define services to exchange data or do code reuse
    - Especially if we want to exchange data between controllers, there are situations where injecting a service is _NOT_ an elegant way of doing this!
    - ***Different ways to let components communicate with each other are described/listed in Lecture 34 part 1!!!*** 
+ Publish-Subscriber Systems are ***ALWAYS*** event based systems!
+ AngularJS implements the ***Publisher-Subscriber Pattern*** to let components communicate with each other!
    - Is implemented via the Event System in AngularJS
    - "A publisher sends messages to subscribers on a common channel"
    * *Publisher*: 
        + Mark messages with a classification (aka topic)
        + A publisher does _NOT_ know who the subscribers are and if there are any subscribers
    * *Subscriber*:
        + Sign up to listen for messages on a particular classification (aka topic)
        + Publisher do _NOT_ know from which publisher a message comes and if there are any publisher that send messages on that classification mark/topic
+ Angulars Publisher-Subscriber System: 
    * The common channel is `scope`
    * Messages are events that _can_ hold data 
+ To publish a message in AngularJS, we need to call `$scope.$emit`
    * This will propagate the message throu the scope chain until the `ng-app` scope is reached!
    [](images/emit.png)
    * Another way to publish messages is to broadcast messages with `$scope.$broadcast`. Thereby, events/messages go ***DOWN*** the chain scope
    [](images/broadcast.png)
    * To broadcast to all controllers also on the same hirachie level, we can use `$rootScope.$broadcast`. Every component in the AngularJS controller hirachie will receive the so published event and _COULD_ (not must) respond to it! 
    [](images/rootScope.png)
    + It is best practice to use a `'namespace:eventName'` as name of the message on the name property to define which components should subscribe to that event!
    + If we call `$rootScope.emit()`, only the root scope is able to see the published message from the controller that was calling this publisher function!
+ Subscribe to a topic in AngularJS: 
    * This is done by `$scope.$on('topic', handlerFcn)`     
+ ***CAUTION***: If we listen for an event on the `$rootScope`, the listener is active as long as the web application runs. Therefore, if we destroy a controller on runtime that subscribed to the `$rootScope`, we need to call the destructor of the listener to unregister and destory it. If we don't do this, we will cause a memory leak. 
    * Therefore, we can save the ID of the listener on the `$rootScope` and then call its function on destruction of the controller object / at the end of the directive function!
    [](images/memory_leak_avoidance.png)
+ See Lecture 34 part 2 for implementation details

## Modules in AngularJS
+ Modules are used to modularize an application
    * That means that we are able to break our implementation of the application down in smaller parts that are easier to handle
+ We can define module artifacts that are handed over to the angular system. You can imagine that the AngularJS system is like a main function that calls our modules
+ In the brackets after the module name (if we declare it in `angular.module('modName', [mod1Name, mod2Name])`) we can declare dependend modules
+ ***Best Practice***: 
    * Declare one module per `.js` file and call them within another file that implements the controller, i.e.: 
    [](images/file_separation.png) 
    * This is possible since the browser combines all files that are defined in the HTML document sequentially into one imaginary javascript file that is executed.
    * This makes the code much more structured 
+ If we define a module as a dependency, the `$scope` of the dependend module is available in the scope where the dependend module is included!
+ _ALL_ `.config()` methods of modules get invoked first before angular creates the modules 
+ Example: Lecture 35 part 2

 ## Routing in AngularJS
 
 ### Classical Client-Server Interaction: 
 + Minor updates of the page (i.e. a name was entered to a list in the HTML page) will cause a completly new created page from the server. This is called "coarse-granined updated"
 + Routing from view to view is done by the server
 [](images/coarse_grained_updates.png)
 ### Web 2.0 Client-Server Communication:
 + Minor updates of the page need a request to the server and the server then sends the data only the relevant data back. Then, the data gets rendered through the javascript engine. This is called "fine-grained updates".
 + Routing through views is also done by the server
[](images/web2_0.png)

==> The problem with the two above approaches is that it is not possible to go back with user entries to older states of the website. The user needs to insert user names, items, ... (all user interaction) again to restore the latest website state. 

### Single Page Application (SPA) Model
+ Update the view with javascript
    * The browser still thinks that a new web page is loaded! 
+ The `#` on a GET, POST, ... request from the client (aka browser) tells javascript to ***NOT*** request a new ressource from the server ***BUT*** to go to another view that was already transmitted by the initial `index.html`. Remark: The change of the view _could_ cause a request for data from the server _OR_ cause a request for a new template from the server
    - If you see a `#` in the browsers URL, you can guess that the website you are currently on is a single page web application!
    - This enables us to go back and forth with the buttons on the browser window! (Because all states are saved as a url in the browser history)
        * Modern browsers could do this without the `#` in front of the URL, if we use HTML5 mode
+ Routing is done by the client (aka browser)
[](images/spa_1.png)
+ Besides the `#` method, it is possible to implement a SPA model by only using javascript to render the page partly new. 
    - The state is then safed in a javascript object. (Instead of safeing it into the browser URL)
[](images/spa_2.png)

## Routing with AngularJS
[](images/routing_libraries_with_angular.png)
+ Step 1: Load the routing package _AFTER_ the normal `angular.js` package, since the routing package is dependend on the normal angular package. 
[](images/routing_step_1.png)
+ Step 2: Define a place in the HTML page where the interchangeable view should be placed
[](images/routing_step_2.png)
+ Step 3: Declare the UI-router as a dependency
[](images/routing_step_3.png)
+ Step 4: Define a configuration though `.config()` for the routing service and inject the configuration services into the routing object.
[](images/routing_step_4_1.png)
[](images/routing_step_4_2.png)
    * The UI states need a unique name and a unique url whereas the URL is optionally. If you do not hand over a URL it is deduced by the states name
    * The `.state(...)` is chainable on the `$stateProvider` service, such that we can define multiple states on it.  
    * If a url is not implemented, we can define a `.otherwise(...)` method where the user will be routed to if an invalid state / url was requested!
[](images/routing_step_4_3.png) 