# Notes week 4

## Component Based Architecture
+ Components are a special type of directive
    - Components are part of the AngularJS version 2 and are introduced in the latest versions of AngularJS version 1
+ Basics to components and component based architecture
    - "Components only control their own view and data."
        * They never modify data or DOM outside their scope 
        * AngularJS components always use isolate scope!
    - "Components have well-defined public API - Input and Output"
        * Inputs are just be done by one way bindings (i.e. `<` or `@`) --> The component should ***NOT*** modify the value of a handed over variable
            - Even if a one-way binding is fixed in the memory that the bound variable is pointing to, the component would be able to modify the variables value. _BUT_ in order to have a well defined API (aka Input-Output behaviour), the value behind a bound variable should ***NEVER*** be changed!
            - APIs (aka a component) should always hand over an output value!
                * The output should be a bidirectional binding by using the `&` binding operation!
                * The data should be passed to the caller of the callback through a parameter map `{key: val}`
    - "Components have well-defined lifecycle"
        * That meanes we have methods that we could call at a defined time of our application
            - i.e. `$onInit` to initialize things for your controller
            - i.e. `$inChanges(changeObj)` will be called whenever a one-way binding is updated
                * `changeObj.currentValue` and `changeObj.previousValue` are attributes of the changed object such that we can track changes. These two attributes are automatically generated by AngularJS
            - i.e. `$postLink` - similar to the `link` attribute in the directive definition
                + In order to use this, we need to inject the `$element` service into our controller ~ element is an abstraction for jquery in angular!
            - i.e. `$onDestroy` - is called when the scope is about to get destroyed
                + _These functions are defined ***on the controller***_
    - "Application is a tree of components"
        * The entire web application shoud be comprised of components
            - Each one would have a well-defined input and output
            - Two-Way Binding is minimized as much as possible
+ Component definition in AngularJS: 
[](images/component_definition.png)
[](images/component_definition_2.png)
+ The main difference/advantage of a controller over a directive is that it is much easier to define since it needs an definition object instead of a creation function and it defines a `$ctrl` service within the controller where it is used. Therefore, there is no need to use the `controller as ctrl` syntax like it was useful in the directive implementation
    * The controller definition is done by an object literal in the registration on `angular.module("AppName", []).component("ComponentName", objLiteral)`
+ See Lecture 33 part 2 for an implementation example
+ In AngularJS version 2, we do not want to depend on `$scope`. Therefore, components are a very good possibility to do this

## Event System
+ To share data between components (or directives) we can define services to exchange data or do code reuse
    - Especially if we want to exchange data between controllers, there are situations where injecting a service is _NOT_ an elegant way of doing this!
    - ***Different ways to let components communicate with each other are described/listed in Lecture 34 part 1!!!*** 
+ Publish-Subscriber Systems are ***ALWAYS*** event based systems!
+ AngularJS implements the ***Publisher-Subscriber Pattern*** to let components communicate with each other!
    - Is implemented via the Event System in AngularJS
    - "A publisher sends messages to subscribers on a common channel"
    * *Publisher*: 
        + Mark messages with a classification (aka topic)
        + A publisher does _NOT_ know who the subscribers are and if there are any subscribers
    * *Subscriber*:
        + Sign up to listen for messages on a particular classification (aka topic)
        + Publisher do _NOT_ know from which publisher a message comes and if there are any publisher that send messages on that classification mark/topic
+ Angulars Publisher-Subscriber System: 
    * The common channel is `scope`
    * Messages are events that _can_ hold data 
+ To publish a message in AngularJS, we need to call `$scope.$emit`
    * This will propagate the message throu the scope chain until the `ng-app` scope is reached!
    [](images/emit.png)
    * Another way to publish messages is to broadcast messages with `$scope.$broadcast`. Thereby, events/messages go ***DOWN*** the chain scope
    [](images/broadcast.png)
    * To broadcast to all controllers also on the same hirachie level, we can use `$rootScope.$broadcast`. Every component in the AngularJS controller hirachie will receive the so published event and _COULD_ (not must) respond to it! 
    [](images/rootScope.png)
    + It is best practice to use a `'namespace:eventName'` as name of the message on the name property to define which components should subscribe to that event!
    + If we call `$rootScope.emit()`, only the root scope is able to see the published message from the controller that was calling this publisher function!
+ Subscribe to a topic in AngularJS: 
    * This is done by `$scope.$on('topic', handlerFcn)`     
+ ***CAUTION***: If we listen for an event on the `$rootScope`, the listener is active as long as the web application runs. Therefore, if we destroy a controller on runtime that subscribed to the `$rootScope`, we need to call the destructor of the listener to unregister and destory it. If we don't do this, we will cause a memory leak. 
    * Therefore, we can save the ID of the listener on the `$rootScope` and then call its function on destruction of the controller object / at the end of the directive function!
    [](images/memory_leak_avoidance.png)
+ See Lecture 34 part 2 for implementation details

## Modules in AngularJS
+ Modules are used to modularize an application
    * That means that we are able to break our implementation of the application down in smaller parts that are easier to handle
+ We can define module artifacts that are handed over to the angular system. You can imagine that the AngularJS system is like a main function that calls our modules
+ In the brackets after the module name (if we declare it in `angular.module('modName', [mod1Name, mod2Name])`) we can declare dependend modules
+ ***Best Practice***: 
    * Declare one module per `.js` file and call them within another file that implements the controller, i.e.: 
    [](images/file_separation.png) 
    * This is possible since the browser combines all files that are defined in the HTML document sequentially into one imaginary javascript file that is executed.
    * This makes the code much more structured 
+ If we define a module as a dependency, the `$scope` of the dependend module is available in the scope where the dependend module is included!
+ _ALL_ `.config()` methods of modules get invoked first before angular creates the modules 
+ Example: Lecture 35 part 2

 