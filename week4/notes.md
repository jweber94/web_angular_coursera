# Notes week 4

## Component Based Architecture
+ Components are a special type of directive
    - Components are part of the AngularJS version 2 and are introduced in the latest versions of AngularJS version 1
+ Basics to components and component based architecture
    - "Components only control their own view and data."
        * They never modify data or DOM outside their scope 
        * AngularJS components always use isolate scope!
    - "Components have well-defined public API - Input and Output"
        * Inputs are just be done by one way bindings (i.e. `<` or `@`) --> The component should ***NOT*** modify the value of a handed over variable
            - Even if a one-way binding is fixed in the memory that the bound variable is pointing to, the component would be able to modify the variables value. _BUT_ in order to have a well defined API (aka Input-Output behaviour), the value behind a bound variable should ***NEVER*** be changed!
            - APIs (aka a component) should always hand over an output value!
                * The output should be a bidirectional binding by using the `&` binding operation!
                * The data should be passed to the caller of the callback through a parameter map `{key: val}`
    - "Components have well-defined lifecycle"
        * That meanes we have methods that we could call at a defined time of our application
            - i.e. `$onInit` to initialize things for your controller
            - i.e. `$inChanges(changeObj)` will be called whenever a one-way binding is updated
                * `changeObj.currentValue` and `changeObj.previousValue` are attributes of the changed object such that we can track changes. These two attributes are automatically generated by AngularJS
            - i.e. `$postLink` - similar to the `link` attribute in the directive definition
                + In order to use this, we need to inject the `$element` service into our controller ~ element is an abstraction for jquery in angular!
            - i.e. `$onDestroy` - is called when the scope is about to get destroyed
                + _These functions are defined ***on the controller***_
    - "Application is a tree of components"
        * The entire web application shoud be comprised of components
            - Each one would have a well-defined input and output
            - Two-Way Binding is minimized as much as possible
+ Component definition in AngularJS: 
[](images/component_definition.png)
[](images/component_definition_2.png)
+ The main difference/advantage of a controller over a directive is that it is much easier to define since it needs an definition object instead of a creation function and it defines a `$ctrl` service within the controller where it is used. Therefore, there is no need to use the `controller as ctrl` syntax like it was useful in the directive implementation
    * The controller definition is done by an object literal in the registration on `angular.module("AppName", []).component("ComponentName", objLiteral)`
+ See Lecture 33 part 2 for an implementation example
+ In AngularJS version 2, we do not want to depend on `$scope`. Therefore, components are a very good possibility to do this

## Event System
+ To share data between components (or directives) we can define services to exchange data or do code reuse
    - Especially if we want to exchange data between controllers, there are situations where injecting a service is _NOT_ an elegant way of doing this!
    - ***Different ways to let components communicate with each other are described/listed in Lecture 34 part 1!!!*** 
+ Publish-Subscriber Systems are ***ALWAYS*** event based systems!
+ AngularJS implements the ***Publisher-Subscriber Pattern*** to let components communicate with each other!
    - Is implemented via the Event System in AngularJS
    - "A publisher sends messages to subscribers on a common channel"
    * *Publisher*: 
        + Mark messages with a classification (aka topic)
        + A publisher does _NOT_ know who the subscribers are and if there are any subscribers
    * *Subscriber*:
        + Sign up to listen for messages on a particular classification (aka topic)
        + Publisher do _NOT_ know from which publisher a message comes and if there are any publisher that send messages on that classification mark/topic
+ Angulars Publisher-Subscriber System: 
    * The common channel is `scope`
    * Messages are events that _can_ hold data 
+ To publish a message in AngularJS, we need to call `$scope.$emit`
    * This will propagate the message throu the scope chain until the `ng-app` scope is reached!
    [](images/emit.png)
    * Another way to publish messages is to broadcast messages with `$scope.$broadcast`. Thereby, events/messages go ***DOWN*** the chain scope
    [](images/broadcast.png)
    * To broadcast to all controllers also on the same hirachie level, we can use `$rootScope.$broadcast`. Every component in the AngularJS controller hirachie will receive the so published event and _COULD_ (not must) respond to it! 
    [](images/rootScope.png)
    + It is best practice to use a `'namespace:eventName'` as name of the message on the name property to define which components should subscribe to that event!
    + If we call `$rootScope.emit()`, only the root scope is able to see the published message from the controller that was calling this publisher function!
+ Subscribe to a topic in AngularJS: 
    * This is done by `$scope.$on('topic', handlerFcn)`     
+ ***CAUTION***: If we listen for an event on the `$rootScope`, the listener is active as long as the web application runs. Therefore, if we destroy a controller on runtime that subscribed to the `$rootScope`, we need to call the destructor of the listener to unregister and destory it. If we don't do this, we will cause a memory leak. 
    * Therefore, we can save the ID of the listener on the `$rootScope` and then call its function on destruction of the controller object / at the end of the directive function!
    [](images/memory_leak_avoidance.png)
+ See Lecture 34 part 2 for implementation details

## Modules in AngularJS
+ Modules are used to modularize an application
    * That means that we are able to break our implementation of the application down in smaller parts that are easier to handle
+ We can define module artifacts that are handed over to the angular system. You can imagine that the AngularJS system is like a main function that calls our modules
+ In the brackets after the module name (if we declare it in `angular.module('modName', [mod1Name, mod2Name])`) we can declare dependend modules
+ ***Best Practice***: 
    * Declare one module per `.js` file and call them within another file that implements the controller, i.e.: 
    [](images/file_separation.png) 
    * This is possible since the browser combines all files that are defined in the HTML document sequentially into one imaginary javascript file that is executed.
    * This makes the code much more structured 
+ If we define a module as a dependency, the `$scope` of the dependend module is available in the scope where the dependend module is included!
+ _ALL_ `.config()` methods of modules get invoked first before angular creates the modules 
+ Example: Lecture 35 part 2

 ## Routing in AngularJS
 
 ### Classical Client-Server Interaction: 
 + Minor updates of the page (i.e. a name was entered to a list in the HTML page) will cause a completly new created page from the server. This is called "coarse-granined updated"
 + Routing from view to view is done by the server
 [](images/coarse_grained_updates.png)
 ### Web 2.0 Client-Server Communication:
 + Minor updates of the page need a request to the server and the server then sends the data only the relevant data back. Then, the data gets rendered through the javascript engine. This is called "fine-grained updates".
 + Routing through views is also done by the server
[](images/web2_0.png)

==> The problem with the two above approaches is that it is not possible to go back with user entries to older states of the website. The user needs to insert user names, items, ... (all user interaction) again to restore the latest website state. 

### Single Page Application (SPA) Model
+ Update the view with javascript
    * The browser still thinks that a new web page is loaded! 
+ The `#` on a GET, POST, ... request from the client (aka browser) tells javascript to ***NOT*** request a new ressource from the server ***BUT*** to go to another view that was already transmitted by the initial `index.html`. Remark: The change of the view _could_ cause a request for data from the server _OR_ cause a request for a new template from the server
    - If you see a `#` in the browsers URL, you can guess that the website you are currently on is a single page web application!
    - This enables us to go back and forth with the buttons on the browser window! (Because all states are saved as a url in the browser history)
        * Modern browsers could do this without the `#` in front of the URL, if we use HTML5 mode
+ Routing is done by the client (aka browser)
[](images/spa_1.png)
+ Besides the `#` method, it is possible to implement a SPA model by only using javascript to render the page partly new. 
    - The state is then safed in a javascript object. (Instead of safeing it into the browser URL)
[](images/spa_2.png)

## Routing with AngularJS
[](images/routing_libraries_with_angular.png)
+ Step 1: Load the routing package _AFTER_ the normal `angular.js` package, since the routing package is dependend on the normal angular package. 
[](images/routing_step_1.png)
+ Step 2: Define a place in the HTML page where the interchangeable view should be placed
[](images/routing_step_2.png)
+ Step 3: Declare the UI-router as a dependency
[](images/routing_step_3.png)
+ Step 4: Define a configuration though `.config()` for the routing service and inject the configuration services into the routing object.
[](images/routing_step_4_1.png)
[](images/routing_step_4_2.png)
    * The UI states need a unique name and a unique url whereas the URL is optionally. If you do not hand over a URL it is deduced by the states name
    * The `.state(...)` is chainable on the `$stateProvider` service, such that we can define multiple states on it.  
    * If a url is not implemented, we can define a `.otherwise(...)` method where the user will be routed to if an invalid state / url was requested!
[](images/routing_step_4_3.png) 
### Download the UI-Router package for AngularJS
+ The version used in this course is 0.3.1 (the latest stable version)
    - See all version: https://cdnjs.com/libraries/angular-ui-router/0.3.1
    - This is the link for the version: https://cdnjs.cloudflare.com/ajax/libs/angular-ui-router/0.3.1/angular-ui-router.js
        * Download this with `$ curl https://cdnjs.cloudflare.com/ajax/libs/angular-ui-router/0.3.1/angular-ui-router.js -o angular-ui-router.js`
+ The `ui-router` brings some new HTML tag-attributes with it to link states to bottons, links, ... 
    - e.g. `<a ui-sref="stateName"></a>`
        * sref = state reference 
        * `ui-sref` does ***NOT*** need a URL but _can_ use it. If no url is defined on the javascript object of the ui-router state, the reference could be set by the name of the state!
+ See a very basic implementation example in the code of Lecture 36 part 2
+ The AngularJS controller could be associated with a state of the ui-router by defining it within the `.state()` method. 
[](images/state_controller.png) 
    * The name of the controller could be defined directly on the state definition and does not need an extra tag attribute in the template. See Lecture 37 part 2 for more details. 
## `resolve` property on the state definition 
+ We can hand over services or data to a state (and therefore into the associated controller) by using the `resolve` property. 
    * If the resolved data is an asynchronous call, the resolve will wait until the promise from the asynchronous call is filled with data. 
    * See Lecture 38 part 2 for Details
+ Main takeaway: If we use resolve, the state will be rendered always after the data is completly resolved. If not, the page will not be shown/rendered! 
## Routing with parameters within the URL 
+ We can use parameters in the state URLs (quiet like the query parameter in HTTP requests within URLs)
[](images/spa_url_parameters.png)
[](images/spa_url_parameters_2.png)
[](images/spa_url_parameters_3.png)
### Example of routing with parameters: 
+ Clickable lists that points to details
+ _See Lecture 39 part 2 for a VERY good example of it!!!_
    * Remark: If we hardcode the properties and do not get the information from a server, we do not need to implement it this way, since we could link another page in our URL space on the server where the pages comes from. But for learning purposes or to get data from a server this is a very good way of doing this! 

## Nested views and routing
+ Sometimes we do NOT want to define a new state for a view of our web page, since the data that we already requested for the current state of our application is only viewed in a different way. 
    * In order to reuse the already requested data, we can define child-states on a state. 
        - A child state inherits all data from the parent state and therefore it can use it without a new server call. 
+ The above described pattern is the ***Master Details View Pair***!
+ Syntax: 
[](images/child_state_spa.png)
    + The nameing is not like in the picture. We need to use the concrete names of the parents and the childs state (not just `.child`)
+ Inserting the data to the controller of the child state: 
[](images/child_state_spa_2.png)
+ The `$stateParams` gives us the parameters from the states URL (See Routing with parameters within the URL)
+ See Lecture 40 part 2 for an implementation example

## Router State Transition Events
+ It is possible to fire up a function on some events that the UI-router triggers. I.e. making a request, handling a failed request, ...
    * With this it is possible to show a loading bar while data from the server is retrieved etc. 
+ ***All browser events are fired at the `$rootScope` level of the scopes!***
    * Therefore, all directives/modules down the DOM _can_ (not must!) respond to the event. 
    * This is a kind of message passing through out _ALL_ modules of the web application 
+ `$stateChangeStart`:
    * Fires when the state change begins --> Good for invokeing a loading screen on the page
    [](images/state_change_start.png)
+ `$stateChangeSuccess`:
    * Fires when the state change finished --> Good for stopping the loading screen
    [](images/state_change_success.png)
+ `$stateChangeError`:
    * Fires when an error occures while the state transition is tried out. --> NO ERROR WILL BE DISPLAYED ON A FAILED STATE TRANSITION. Only this message will be fired!
    [](images/state_change_error.png)

==> Documentation for UI-Router: 
https://github.com/angular-ui/ui-router